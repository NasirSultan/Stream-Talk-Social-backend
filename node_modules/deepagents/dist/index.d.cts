import * as zod_v30 from "zod/v3";
import * as langchain from "langchain";
import { AgentMiddleware, AgentMiddleware as AgentMiddleware$1, AgentTypeConfig, InferMiddlewareStates, InterruptOnConfig, ProviderStrategy, ReactAgent, ResponseFormat, ResponseFormatUndefined, StructuredTool, SystemMessage, ToolMessage, ToolStrategy } from "langchain";
import * as _langchain_langgraph0 from "@langchain/langgraph";
import { AnnotationRoot, Command, ReducedValue, StateSchema } from "@langchain/langgraph";
import { z } from "zod/v4";
import { BaseCheckpointSaver, BaseStore } from "@langchain/langgraph-checkpoint";
import * as _messages from "@langchain/core/messages";
import * as zod from "zod";
import { z as z$1 } from "zod";
import * as zod_v4_core0 from "zod/v4/core";
import * as _langchain_core_language_models_base0 from "@langchain/core/language_models/base";
import { BaseLanguageModel, LanguageModelLike } from "@langchain/core/language_models/base";
import * as _langchain_core_tools0 from "@langchain/core/tools";
import { ClientTool, ServerTool, StructuredTool as StructuredTool$1 } from "@langchain/core/tools";
import { Runnable } from "@langchain/core/runnables";
import "@langchain/core/language_models/chat_models";
import { InteropZodObject } from "@langchain/core/utils/types";

//#region src/backends/protocol.d.ts
type MaybePromise<T> = T | Promise<T>;
/**
 * Structured file listing info.
 *
 * Minimal contract used across backends. Only "path" is required.
 * Other fields are best-effort and may be absent depending on backend.
 */
interface FileInfo {
  /** File path */
  path: string;
  /** Whether this is a directory */
  is_dir?: boolean;
  /** File size in bytes (approximate) */
  size?: number;
  /** ISO 8601 timestamp of last modification */
  modified_at?: string;
}
/**
 * Structured grep match entry.
 */
interface GrepMatch {
  /** File path where match was found */
  path: string;
  /** Line number (1-indexed) */
  line: number;
  /** The matching line text */
  text: string;
}
/**
 * File data structure used by backends.
 *
 * All file data is represented as objects with this structure:
 */
interface FileData {
  /** Lines of text content */
  content: string[];
  /** ISO format timestamp of creation */
  created_at: string;
  /** ISO format timestamp of last modification */
  modified_at: string;
}
/**
 * Result from backend write operations.
 *
 * Checkpoint backends populate filesUpdate with {file_path: file_data} for LangGraph state.
 * External backends set filesUpdate to null (already persisted to disk/S3/database/etc).
 */
interface WriteResult {
  /** Error message on failure, undefined on success */
  error?: string;
  /** File path of written file, undefined on failure */
  path?: string;
  /**
   * State update dict for checkpoint backends, null for external storage.
   * Checkpoint backends populate this with {file_path: file_data} for LangGraph state.
   * External backends set null (already persisted to disk/S3/database/etc).
   */
  filesUpdate?: Record<string, FileData> | null;
  /** Metadata for the write operation, attached to the ToolMessage */
  metadata?: Record<string, unknown>;
}
/**
 * Result from backend edit operations.
 *
 * Checkpoint backends populate filesUpdate with {file_path: file_data} for LangGraph state.
 * External backends set filesUpdate to null (already persisted to disk/S3/database/etc).
 */
interface EditResult {
  /** Error message on failure, undefined on success */
  error?: string;
  /** File path of edited file, undefined on failure */
  path?: string;
  /**
   * State update dict for checkpoint backends, null for external storage.
   * Checkpoint backends populate this with {file_path: file_data} for LangGraph state.
   * External backends set null (already persisted to disk/S3/database/etc).
   */
  filesUpdate?: Record<string, FileData> | null;
  /** Number of replacements made, undefined on failure */
  occurrences?: number;
  /** Metadata for the edit operation, attached to the ToolMessage */
  metadata?: Record<string, unknown>;
}
/**
 * Result of code execution.
 * Simplified schema optimized for LLM consumption.
 */
interface ExecuteResponse {
  /** Combined stdout and stderr output of the executed command */
  output: string;
  /** The process exit code. 0 indicates success, non-zero indicates failure */
  exitCode: number | null;
  /** Whether the output was truncated due to backend limitations */
  truncated: boolean;
}
/**
 * Standardized error codes for file upload/download operations.
 */
type FileOperationError = "file_not_found" | "permission_denied" | "is_directory" | "invalid_path";
/**
 * Result of a single file download operation.
 */
interface FileDownloadResponse {
  /** The file path that was requested */
  path: string;
  /** File contents as Uint8Array on success, null on failure */
  content: Uint8Array | null;
  /** Standardized error code on failure, null on success */
  error: FileOperationError | null;
}
/**
 * Result of a single file upload operation.
 */
interface FileUploadResponse {
  /** The file path that was requested */
  path: string;
  /** Standardized error code on failure, null on success */
  error: FileOperationError | null;
}
/**
 * Protocol for pluggable memory backends (single, unified).
 *
 * Backends can store files in different locations (state, filesystem, database, etc.)
 * and provide a uniform interface for file operations.
 *
 * All file data is represented as objects with the FileData structure.
 *
 * Methods can return either direct values or Promises, allowing both
 * synchronous and asynchronous implementations.
 */
interface BackendProtocol {
  /**
   * Structured listing with file metadata.
   *
   * Lists files and directories in the specified directory (non-recursive).
   * Directories have a trailing / in their path and is_dir=true.
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects for files and directories directly in the directory
   */
  lsInfo(path: string): MaybePromise<FileInfo[]>;
  /**
   * Read file content with line numbers or an error string.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed), default 0
   * @param limit - Maximum number of lines to read, default 500
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset?: number, limit?: number): MaybePromise<string>;
  /**
   * Read file content as raw FileData.
   *
   * @param filePath - Absolute file path
   * @returns Raw file content as FileData
   */
  readRaw(filePath: string): MaybePromise<FileData>;
  /**
   * Structured search results or error string for invalid input.
   *
   * Searches file contents for a regex pattern.
   *
   * @param pattern - Regex pattern to search for
   * @param path - Base path to search from (default: null)
   * @param glob - Optional glob pattern to filter files (e.g., "*.py")
   * @returns List of GrepMatch objects or error string for invalid regex
   */
  grepRaw(pattern: string, path?: string | null, glob?: string | null): MaybePromise<GrepMatch[] | string>;
  /**
   * Structured glob matching returning FileInfo objects.
   *
   * @param pattern - Glob pattern (e.g., `*.py`, `**\/*.ts`)
   * @param path - Base path to search from (default: "/")
   * @returns List of FileInfo objects matching the pattern
   */
  globInfo(pattern: string, path?: string): MaybePromise<FileInfo[]>;
  /**
   * Create a new file.
   *
   * @param filePath - Absolute file path
   * @param content - File content as string
   * @returns WriteResult with error populated on failure
   */
  write(filePath: string, content: string): MaybePromise<WriteResult>;
  /**
   * Edit a file by replacing string occurrences.
   *
   * @param filePath - Absolute file path
   * @param oldString - String to find and replace
   * @param newString - Replacement string
   * @param replaceAll - If true, replace all occurrences (default: false)
   * @returns EditResult with error, path, filesUpdate, and occurrences
   */
  edit(filePath: string, oldString: string, newString: string, replaceAll?: boolean): MaybePromise<EditResult>;
  /**
   * Upload multiple files.
   * Optional - backends that don't support file upload can omit this.
   *
   * @param files - List of [path, content] tuples to upload
   * @returns List of FileUploadResponse objects, one per input file
   */
  uploadFiles?(files: Array<[string, Uint8Array]>): MaybePromise<FileUploadResponse[]>;
  /**
   * Download multiple files.
   * Optional - backends that don't support file download can omit this.
   *
   * @param paths - List of file paths to download
   * @returns List of FileDownloadResponse objects, one per input path
   */
  downloadFiles?(paths: string[]): MaybePromise<FileDownloadResponse[]>;
}
/**
 * Protocol for sandboxed backends with isolated runtime.
 * Sandboxed backends run in isolated environments (e.g., containers)
 * and communicate via defined interfaces.
 */
interface SandboxBackendProtocol extends BackendProtocol {
  /**
   * Execute a command in the sandbox.
   *
   * @param command - Full shell command string to execute
   * @returns ExecuteResponse with combined output, exit code, and truncation flag
   */
  execute(command: string): MaybePromise<ExecuteResponse>;
  /** Unique identifier for the sandbox backend instance */
  readonly id: string;
}
/**
 * Type guard to check if a backend supports execution.
 *
 * @param backend - Backend instance to check
 * @returns True if the backend implements SandboxBackendProtocol
 */
declare function isSandboxBackend(backend: BackendProtocol): backend is SandboxBackendProtocol;
/**
 * Metadata for a single sandbox instance.
 *
 * This lightweight structure is returned from list operations and provides
 * basic information about a sandbox without requiring a full connection.
 *
 * @typeParam MetadataT - Type of the metadata field. Providers can define
 *   their own interface for type-safe metadata access.
 *
 * @example
 * ```typescript
 * // Using default metadata type
 * const info: SandboxInfo = {
 *   sandboxId: "sb_abc123",
 *   metadata: { status: "running", createdAt: "2024-01-15T10:30:00Z" },
 * };
 *
 * // Using typed metadata
 * interface MyMetadata {
 *   status: "running" | "stopped";
 *   createdAt: string;
 * }
 * const typedInfo: SandboxInfo<MyMetadata> = {
 *   sandboxId: "sb_abc123",
 *   metadata: { status: "running", createdAt: "2024-01-15T10:30:00Z" },
 * };
 * ```
 */
interface SandboxInfo<MetadataT = Record<string, unknown>> {
  /** Unique identifier for the sandbox instance */
  sandboxId: string;
  /** Optional provider-specific metadata (e.g., creation time, status, template) */
  metadata?: MetadataT;
}
/**
 * Paginated response from a sandbox list operation.
 *
 * This structure supports cursor-based pagination for efficiently browsing
 * large collections of sandboxes.
 *
 * @typeParam MetadataT - Type of the metadata field in SandboxInfo items.
 *
 * @example
 * ```typescript
 * const response: SandboxListResponse = {
 *   items: [
 *     { sandboxId: "sb_001", metadata: { status: "running" } },
 *     { sandboxId: "sb_002", metadata: { status: "stopped" } },
 *   ],
 *   cursor: "eyJvZmZzZXQiOjEwMH0=",
 * };
 *
 * // Fetch next page
 * const nextResponse = await provider.list({ cursor: response.cursor });
 * ```
 */
interface SandboxListResponse<MetadataT = Record<string, unknown>> {
  /** List of sandbox metadata objects for the current page */
  items: SandboxInfo<MetadataT>[];
  /**
   * Opaque continuation token for retrieving the next page.
   * null indicates no more pages available.
   */
  cursor: string | null;
}
/**
 * Options for listing sandboxes.
 */
interface SandboxListOptions {
  /**
   * Continuation token from a previous list() call.
   * Pass undefined to start from the beginning.
   */
  cursor?: string;
}
/**
 * Options for getting or creating a sandbox.
 */
interface SandboxGetOrCreateOptions {
  /**
   * Unique identifier of an existing sandbox to retrieve.
   * If undefined, creates a new sandbox instance.
   * If provided but the sandbox doesn't exist, an error will be thrown.
   */
  sandboxId?: string;
}
/**
 * Options for deleting a sandbox.
 */
interface SandboxDeleteOptions {
  /** Unique identifier of the sandbox to delete */
  sandboxId: string;
}
/**
 * Common error codes shared across all sandbox provider implementations.
 *
 * These represent the core error conditions that any sandbox provider may encounter.
 * Provider-specific error codes should extend this type with additional codes.
 *
 * @example
 * ```typescript
 * // Provider-specific error code type extending the common codes:
 * type MySandboxErrorCode = SandboxErrorCode | "CUSTOM_ERROR";
 * ```
 */
type SandboxErrorCode = /** Sandbox has not been initialized - call initialize() first */"NOT_INITIALIZED" /** Sandbox is already initialized - cannot initialize twice */ | "ALREADY_INITIALIZED" /** Command execution timed out */ | "COMMAND_TIMEOUT" /** Command execution failed */ | "COMMAND_FAILED" /** File operation (read/write) failed */ | "FILE_OPERATION_FAILED";
declare const SANDBOX_ERROR_SYMBOL: unique symbol;
/**
 * Custom error class for sandbox operations.
 *
 * @param message - Human-readable error description
 * @param code - Structured error code for programmatic handling
 * @returns SandboxError with message and code
 *
 * @example
 * ```typescript
 * try {
 *   await sandbox.execute("some command");
 * } catch (error) {
 *   if (error instanceof SandboxError) {
 *     switch (error.code) {
 *       case "NOT_INITIALIZED":
 *         await sandbox.initialize();
 *         break;
 *       case "COMMAND_TIMEOUT":
 *         console.error("Command took too long");
 *         break;
 *       default:
 *         throw error;
 *     }
 *   }
 * }
 * ```
 */
declare class SandboxError extends Error {
  readonly code: string;
  readonly cause?: Error | undefined;
  /** Symbol for identifying sandbox error instances */
  [SANDBOX_ERROR_SYMBOL]: true;
  /** Error name for instanceof checks and logging */
  readonly name: string;
  /**
   * Creates a new SandboxError.
   *
   * @param message - Human-readable error description
   * @param code - Structured error code for programmatic handling
   */
  constructor(message: string, code: string, cause?: Error | undefined);
  static isInstance(error: unknown): error is SandboxError;
}
/**
 * State and store container for backend initialization.
 *
 * This provides a clean interface for what backends need to access:
 * - state: Current agent state (with files, messages, etc.)
 * - store: Optional persistent store for cross-conversation data
 *
 * Different contexts build this differently:
 * - Tools: Extract state via getCurrentTaskInput(config)
 * - Middleware: Use request.state directly
 */
interface StateAndStore {
  /** Current agent state with files, messages, etc. */
  state: unknown;
  /** Optional BaseStore for persistent cross-conversation storage */
  store?: BaseStore;
  /** Optional assistant ID for per-assistant isolation in store */
  assistantId?: string;
}
/**
 * Factory function type for creating backend instances.
 *
 * Backends receive StateAndStore which contains the current state
 * and optional store, extracted from the execution context.
 *
 * @example
 * ```typescript
 * // Using in middleware
 * const middleware = createFilesystemMiddleware({
 *   backend: (stateAndStore) => new StateBackend(stateAndStore)
 * });
 * ```
 */
type BackendFactory = (stateAndStore: StateAndStore) => BackendProtocol;
//#endregion
//#region src/middleware/fs.d.ts
/**
 * Type for the files state record.
 */
type FilesRecord = Record<string, FileData>;
/**
 * Type for file updates, where null indicates deletion.
 */
type FilesRecordUpdate = Record<string, FileData | null>;
/**
 * Options for creating filesystem middleware.
 */
interface FilesystemMiddlewareOptions {
  /** Backend instance or factory (default: StateBackend) */
  backend?: BackendProtocol | BackendFactory;
  /** Optional custom system prompt override */
  systemPrompt?: string | null;
  /** Optional custom tool descriptions override */
  customToolDescriptions?: Record<string, string> | null;
  /** Optional token limit before evicting a tool result to the filesystem (default: 20000 tokens, ~80KB) */
  toolTokenLimitBeforeEvict?: number | null;
}
/**
 * Create filesystem middleware with all tools and features.
 */
declare function createFilesystemMiddleware(options?: FilesystemMiddlewareOptions): AgentMiddleware<StateSchema<{
  files: ReducedValue<FilesRecord | undefined, FilesRecordUpdate | undefined>;
}>, undefined, unknown, (langchain.DynamicStructuredTool<z.ZodObject<{
  path: z.ZodDefault<z.ZodOptional<z.ZodString>>;
}, z.core.$strip>, {
  path: string;
}, {
  path?: string | undefined;
}, string, "ls"> | langchain.DynamicStructuredTool<z.ZodObject<{
  file_path: z.ZodString;
  offset: z.ZodDefault<z.ZodOptional<z.ZodCoercedNumber<unknown>>>;
  limit: z.ZodDefault<z.ZodOptional<z.ZodCoercedNumber<unknown>>>;
}, z.core.$strip>, {
  file_path: string;
  offset: number;
  limit: number;
}, {
  file_path: string;
  offset?: unknown;
  limit?: unknown;
}, string, "read_file"> | langchain.DynamicStructuredTool<z.ZodObject<{
  file_path: z.ZodString;
  content: z.ZodString;
}, z.core.$strip>, {
  file_path: string;
  content: string;
}, {
  file_path: string;
  content: string;
}, string | ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>> | Command<unknown, {
  files: Record<string, FileData>;
  messages: ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>>[];
}, string>, "write_file"> | langchain.DynamicStructuredTool<z.ZodObject<{
  file_path: z.ZodString;
  old_string: z.ZodString;
  new_string: z.ZodString;
  replace_all: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
}, z.core.$strip>, {
  file_path: string;
  old_string: string;
  new_string: string;
  replace_all: boolean;
}, {
  file_path: string;
  old_string: string;
  new_string: string;
  replace_all?: boolean | undefined;
}, string | ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>> | Command<unknown, {
  files: Record<string, FileData>;
  messages: ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>>[];
}, string>, "edit_file"> | langchain.DynamicStructuredTool<z.ZodObject<{
  pattern: z.ZodString;
  path: z.ZodDefault<z.ZodOptional<z.ZodString>>;
}, z.core.$strip>, {
  pattern: string;
  path: string;
}, {
  pattern: string;
  path?: string | undefined;
}, string, "glob"> | langchain.DynamicStructuredTool<z.ZodObject<{
  pattern: z.ZodString;
  path: z.ZodDefault<z.ZodOptional<z.ZodString>>;
  glob: z.ZodNullable<z.ZodOptional<z.ZodString>>;
}, z.core.$strip>, {
  pattern: string;
  path: string;
  glob?: string | null | undefined;
}, {
  pattern: string;
  path?: string | undefined;
  glob?: string | null | undefined;
}, string, "grep"> | langchain.DynamicStructuredTool<z.ZodObject<{
  command: z.ZodString;
}, z.core.$strip>, {
  command: string;
}, {
  command: string;
}, string, "execute">)[]>;
//#endregion
//#region src/middleware/subagents.d.ts
/**
 * Default system prompt for subagents.
 * Provides a minimal base prompt that can be extended by specific subagent configurations.
 */
declare const DEFAULT_SUBAGENT_PROMPT = "In order to complete the objective that the user asks of you, you have access to a number of standard tools.";
/**
 * Default description for the general-purpose subagent.
 * This description is shown to the model when selecting which subagent to use.
 */
declare const DEFAULT_GENERAL_PURPOSE_DESCRIPTION = "General-purpose agent for researching complex questions, searching for files and content, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries use this agent to perform the search for you. This agent has access to all tools as the main agent.";
/**
 * System prompt section that explains how to use the task tool for spawning subagents.
 *
 * This prompt is automatically appended to the main agent's system prompt when
 * using `createSubAgentMiddleware`. It provides guidance on:
 * - When to use the task tool
 * - Subagent lifecycle (spawn → run → return → reconcile)
 * - When NOT to use the task tool
 * - Best practices for parallel task execution
 *
 * You can provide a custom `systemPrompt` to `createSubAgentMiddleware` to override
 * or extend this default.
 */
declare const TASK_SYSTEM_PROMPT = "## `task` (subagent spawner)\n\nYou have access to a `task` tool to launch short-lived subagents that handle isolated tasks. These agents are ephemeral \u2014 they live only for the duration of the task and return a single result.\n\nWhen to use the task tool:\n- When a task is complex and multi-step, and can be fully delegated in isolation\n- When a task is independent of other tasks and can run in parallel\n- When a task requires focused reasoning or heavy token/context usage that would bloat the orchestrator thread\n- When sandboxing improves reliability (e.g. code execution, structured searches, data formatting)\n- When you only care about the output of the subagent, and not the intermediate steps (ex. performing a lot of research and then returned a synthesized report, performing a series of computations or lookups to achieve a concise, relevant answer.)\n\nSubagent lifecycle:\n1. **Spawn** \u2192 Provide clear role, instructions, and expected output\n2. **Run** \u2192 The subagent completes the task autonomously\n3. **Return** \u2192 The subagent provides a single structured result\n4. **Reconcile** \u2192 Incorporate or synthesize the result into the main thread\n\nWhen NOT to use the task tool:\n- If you need to see the intermediate reasoning or steps after the subagent has completed (the task tool hides them)\n- If the task is trivial (a few tool calls or simple lookup)\n- If delegating does not reduce token usage, complexity, or context switching\n- If splitting would add latency without benefit\n\n## Important Task Tool Usage Notes to Remember\n- Whenever possible, parallelize the work that you do. This is true for both tool_calls, and for tasks. Whenever you have independent steps to complete - make tool_calls, or kick off tasks (subagents) in parallel to accomplish them faster. This saves time for the user, which is incredibly important.\n- Remember to use the `task` tool to silo independent tasks within a multi-part objective.\n- You should use the `task` tool whenever you have a complex task that will take multiple steps, and is independent from other tasks that the agent needs to complete. These agents are highly competent and efficient.";
/**
 * Type definitions for pre-compiled agents.
 *
 * @typeParam TRunnable - The type of the runnable (ReactAgent or Runnable).
 *   When using `createAgent` or `createDeepAgent`, this preserves the middleware
 *   types for type inference. Uses `ReactAgent<any>` to accept agents with any
 *   type configuration (including DeepAgent instances).
 */
interface CompiledSubAgent<TRunnable extends ReactAgent<any> | Runnable = ReactAgent<any> | Runnable> {
  /** The name of the agent */
  name: string;
  /** The description of the agent */
  description: string;
  /** The agent instance */
  runnable: TRunnable;
}
/**
 * Specification for a subagent that can be dynamically created.
 *
 * When using `createDeepAgent`, subagents automatically receive a default middleware
 * stack (todoListMiddleware, filesystemMiddleware, summarizationMiddleware, etc.) before
 * any custom `middleware` specified in this spec.
 *
 * Required fields:
 * - `name`: Identifier used to select this subagent in the task tool
 * - `description`: Shown to the model for subagent selection
 * - `systemPrompt`: The system prompt for the subagent
 *
 * Optional fields:
 * - `model`: Override the default model for this subagent
 * - `tools`: Override the default tools for this subagent
 * - `middleware`: Additional middleware appended after defaults
 * - `interruptOn`: Human-in-the-loop configuration for specific tools
 * - `skills`: Skill source paths for SkillsMiddleware (e.g., `["/skills/user/", "/skills/project/"]`)
 *
 * @example
 * ```typescript
 * const researcher: SubAgent = {
 *   name: "researcher",
 *   description: "Research assistant for complex topics",
 *   systemPrompt: "You are a research assistant.",
 *   tools: [webSearchTool],
 *   skills: ["/skills/research/"],
 * };
 * ```
 */
interface SubAgent {
  /** Identifier used to select this subagent in the task tool */
  name: string;
  /** Description shown to the model for subagent selection */
  description: string;
  /** The system prompt to use for the agent */
  systemPrompt: string;
  /** The tools to use for the agent (tool instances, not names). Defaults to defaultTools */
  tools?: StructuredTool[];
  /** The model for the agent. Defaults to defaultModel */
  model?: LanguageModelLike | string;
  /** Additional middleware to append after default_middleware */
  middleware?: readonly AgentMiddleware$1[];
  /** Human-in-the-loop configuration for specific tools. Requires a checkpointer. */
  interruptOn?: Record<string, boolean | InterruptOnConfig>;
  /**
   * Skill source paths for SkillsMiddleware.
   *
   * List of paths to skill directories (e.g., `["/skills/user/", "/skills/project/"]`).
   * When specified, the subagent will have its own SkillsMiddleware that loads skills
   * from these paths. This allows subagents to have different skill sets than the main agent.
   *
   * Note: Custom subagents do NOT inherit skills from the main agent by default.
   * Only the general-purpose subagent inherits the main agent's skills.
   *
   * @example
   * ```typescript
   * const researcher: SubAgent = {
   *   name: "researcher",
   *   description: "Research assistant",
   *   systemPrompt: "You are a researcher.",
   *   skills: ["/skills/research/", "/skills/web-search/"],
   * };
   * ```
   */
  skills?: string[];
}
/**
 * Base specification for the general-purpose subagent.
 *
 * This constant provides the default configuration for the general-purpose subagent
 * that is automatically included when `generalPurposeAgent: true` (the default).
 *
 * The general-purpose subagent:
 * - Has access to all tools from the main agent
 * - Inherits skills from the main agent (when skills are configured)
 * - Uses the same model as the main agent (by default)
 * - Is ideal for delegating complex, multi-step tasks
 *
 * You can spread this constant and override specific properties when creating
 * custom subagents that should behave similarly to the general-purpose agent:
 *
 * @example
 * ```typescript
 * import { GENERAL_PURPOSE_SUBAGENT, createDeepAgent } from "@anthropic/deepagents";
 *
 * // Use as-is (automatically included with generalPurposeAgent: true)
 * const agent = createDeepAgent({ model: "claude-sonnet-4-5-20250929" });
 *
 * // Or create a custom variant with different tools
 * const customGP: SubAgent = {
 *   ...GENERAL_PURPOSE_SUBAGENT,
 *   name: "research-gp",
 *   tools: [webSearchTool, readFileTool],
 * };
 *
 * const agent = createDeepAgent({
 *   model: "claude-sonnet-4-5-20250929",
 *   subagents: [customGP],
 *   // Disable the default general-purpose agent since we're providing our own
 *   // (handled automatically when using createSubAgentMiddleware directly)
 * });
 * ```
 */
declare const GENERAL_PURPOSE_SUBAGENT: Pick<SubAgent, "name" | "description" | "systemPrompt">;
/**
 * Options for creating subagent middleware
 */
interface SubAgentMiddlewareOptions {
  /** The model to use for subagents */
  defaultModel: LanguageModelLike | string;
  /** The tools to use for the default general-purpose subagent */
  defaultTools?: StructuredTool[];
  /** Default middleware to apply to custom subagents (WITHOUT skills from main agent) */
  defaultMiddleware?: AgentMiddleware$1[] | null;
  /**
   * Middleware specifically for the general-purpose subagent (includes skills from main agent).
   * If not provided, falls back to defaultMiddleware.
   */
  generalPurposeMiddleware?: AgentMiddleware$1[] | null;
  /** The tool configs for the default general-purpose subagent */
  defaultInterruptOn?: Record<string, boolean | InterruptOnConfig> | null;
  /** A list of additional subagents to provide to the agent */
  subagents?: (SubAgent | CompiledSubAgent)[];
  /** Full system prompt override */
  systemPrompt?: string | null;
  /** Whether to include the general-purpose agent */
  generalPurposeAgent?: boolean;
  /** Custom description for the task tool */
  taskDescription?: string | null;
}
/**
 * Create subagent middleware with task tool
 */
declare function createSubAgentMiddleware(options: SubAgentMiddlewareOptions): AgentMiddleware$1<undefined, undefined, unknown, readonly [langchain.DynamicStructuredTool<z.ZodObject<{
  description: z.ZodString;
  subagent_type: z.ZodString;
}, z.core.$strip>, {
  description: string;
  subagent_type: string;
}, {
  description: string;
  subagent_type: string;
}, string | Command<unknown, Record<string, unknown>, string>, "task">]>;
//#endregion
//#region src/middleware/patch_tool_calls.d.ts
/**
 * Create middleware that patches dangling tool calls in the messages history.
 *
 * When an AI message contains tool_calls but subsequent messages don't include
 * the corresponding ToolMessage responses, this middleware adds synthetic
 * ToolMessages saying the tool call was cancelled.
 *
 * This middleware patches in two places:
 * 1. `beforeAgent`: Patches state at the start of the agent loop (handles most cases)
 * 2. `wrapModelCall`: Patches the request right before model invocation (handles
 *    edge cases like HITL rejection during graph resume where state updates from
 *    beforeAgent may not be applied in time)
 *
 * @returns AgentMiddleware that patches dangling tool calls
 *
 * @example
 * ```typescript
 * import { createAgent } from "langchain";
 * import { createPatchToolCallsMiddleware } from "./middleware/patch_tool_calls";
 *
 * const agent = createAgent({
 *   model: "claude-sonnet-4-5-20250929",
 *   middleware: [createPatchToolCallsMiddleware()],
 * });
 * ```
 */
declare function createPatchToolCallsMiddleware(): AgentMiddleware<undefined, undefined, unknown, readonly (_langchain_core_tools0.ClientTool | _langchain_core_tools0.ServerTool)[]>;
//#endregion
//#region src/backends/state.d.ts
/**
 * Backend that stores files in agent state (ephemeral).
 *
 * Uses LangGraph's state management and checkpointing. Files persist within
 * a conversation thread but not across threads. State is automatically
 * checkpointed after each agent step.
 *
 * Special handling: Since LangGraph state must be updated via Command objects
 * (not direct mutation), operations return filesUpdate in WriteResult/EditResult
 * for the middleware to apply via Command.
 */
declare class StateBackend implements BackendProtocol {
  private stateAndStore;
  constructor(stateAndStore: StateAndStore);
  /**
   * Get files from current state.
   */
  private getFiles;
  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects for files and directories directly in the directory.
   *          Directories have a trailing / in their path and is_dir=true.
   */
  lsInfo(path: string): FileInfo[];
  /**
   * Read file content with line numbers.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset?: number, limit?: number): string;
  /**
   * Read file content as raw FileData.
   *
   * @param filePath - Absolute file path
   * @returns Raw file content as FileData
   */
  readRaw(filePath: string): FileData;
  /**
   * Create a new file with content.
   * Returns WriteResult with filesUpdate to update LangGraph state.
   */
  write(filePath: string, content: string): WriteResult;
  /**
   * Edit a file by replacing string occurrences.
   * Returns EditResult with filesUpdate and occurrences.
   */
  edit(filePath: string, oldString: string, newString: string, replaceAll?: boolean): EditResult;
  /**
   * Structured search results or error string for invalid input.
   */
  grepRaw(pattern: string, path?: string, glob?: string | null): GrepMatch[] | string;
  /**
   * Structured glob matching returning FileInfo objects.
   */
  globInfo(pattern: string, path?: string): FileInfo[];
  /**
   * Upload multiple files.
   *
   * Note: Since LangGraph state must be updated via Command objects,
   * the caller must apply filesUpdate via Command after calling this method.
   *
   * @param files - List of [path, content] tuples to upload
   * @returns List of FileUploadResponse objects, one per input file
   */
  uploadFiles(files: Array<[string, Uint8Array]>): FileUploadResponse[] & {
    filesUpdate?: Record<string, FileData>;
  };
  /**
   * Download multiple files.
   *
   * @param paths - List of file paths to download
   * @returns List of FileDownloadResponse objects, one per input path
   */
  downloadFiles(paths: string[]): FileDownloadResponse[];
}
//#endregion
//#region src/middleware/memory.d.ts
/**
 * Options for the memory middleware.
 */
interface MemoryMiddlewareOptions {
  /**
   * Backend instance or factory function for file operations.
   * Use a factory for StateBackend since it requires runtime state.
   */
  backend: BackendProtocol | BackendFactory | ((config: {
    state: unknown;
    store?: BaseStore;
  }) => StateBackend);
  /**
   * List of memory file paths to load (e.g., ["~/.deepagents/AGENTS.md", "./.deepagents/AGENTS.md"]).
   * Display names are automatically derived from the paths.
   * Sources are loaded in order.
   */
  sources: string[];
}
/**
 * Create middleware for loading agent memory from AGENTS.md files.
 *
 * Loads memory content from configured sources and injects into the system prompt.
 * Supports multiple sources that are combined together.
 *
 * @param options - Configuration options
 * @returns AgentMiddleware for memory loading and injection
 *
 * @example
 * ```typescript
 * const middleware = createMemoryMiddleware({
 *   backend: new FilesystemBackend({ rootDir: "/" }),
 *   sources: [
 *     "~/.deepagents/AGENTS.md",
 *     "./.deepagents/AGENTS.md",
 *   ],
 * });
 * ```
 */
declare function createMemoryMiddleware(options: MemoryMiddlewareOptions): AgentMiddleware<StateSchema<{
  /**
   * Dict mapping source paths to their loaded content.
   * Marked as private so it's not included in the final agent state.
   */
  memoryContents: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodString>>;
  files: _langchain_langgraph0.ReducedValue<FilesRecord | undefined, FilesRecordUpdate | undefined>;
}>, undefined, unknown, readonly (_langchain_core_tools0.ClientTool | _langchain_core_tools0.ServerTool)[]>;
//#endregion
//#region src/middleware/skills.d.ts
declare const MAX_SKILL_FILE_SIZE: number;
declare const MAX_SKILL_NAME_LENGTH = 64;
declare const MAX_SKILL_DESCRIPTION_LENGTH = 1024;
/**
 * Metadata for a skill per Agent Skills specification.
 */
interface SkillMetadata$1 {
  /**
   * Skill identifier.
   *
   * Constraints per Agent Skills specification:
   *
   * - 1-64 characters
   * - Unicode lowercase alphanumeric and hyphens only (`a-z` and `-`).
   * - Must not start or end with `-`
   * - Must not contain consecutive `--`
   * - Must match the parent directory name containing the `SKILL.md` file
   */
  name: string;
  /**
   * What the skill does.
   *
   * Constraints per Agent Skills specification:
   *
   * - 1-1024 characters
   * - Should describe both what the skill does and when to use it
   * - Should include specific keywords that help agents identify relevant tasks
   */
  description: string;
  /** Path to the SKILL.md file in the backend */
  path: string;
  /** License name or reference to bundled license file. */
  license?: string | null;
  /**
   * Environment requirements.
   *
   * Constraints per Agent Skills specification:
   *
   * - 1-500 characters if provided
   * - Should only be included if there are specific compatibility requirements
   * - Can indicate intended product, required packages, etc.
   */
  compatibility?: string | null;
  /**
   * Arbitrary key-value mapping for additional metadata.
   *
   * Clients can use this to store additional properties not defined by the spec.
   *
   * It is recommended to keep key names unique to avoid conflicts.
   */
  metadata?: Record<string, string>;
  /**
   * Tool names the skill recommends using.
   *
   * Warning: this is experimental.
   *
   * Constraints per Agent Skills specification:
   *
   * - Space-delimited list of tool names
   */
  allowedTools?: string[];
}
/**
 * Options for the skills middleware.
 */
interface SkillsMiddlewareOptions {
  /**
   * Backend instance or factory function for file operations.
   * Use a factory for StateBackend since it requires runtime state.
   */
  backend: BackendProtocol | BackendFactory | ((config: {
    state: unknown;
    store?: BaseStore;
  }) => StateBackend);
  /**
   * List of skill source paths to load (e.g., ["/skills/user/", "/skills/project/"]).
   * Paths must use POSIX conventions (forward slashes).
   * Later sources override earlier ones for skills with the same name (last one wins).
   */
  sources: string[];
}
/**
 * Create backend-agnostic middleware for loading and exposing agent skills.
 *
 * This middleware loads skills from configurable backend sources and injects
 * skill metadata into the system prompt. It implements the progressive disclosure
 * pattern: skill names and descriptions are shown in the prompt, but the agent
 * reads full SKILL.md content only when needed.
 *
 * @param options - Configuration options
 * @returns AgentMiddleware for skills loading and injection
 *
 * @example
 * ```typescript
 * const middleware = createSkillsMiddleware({
 *   backend: new FilesystemBackend({ rootDir: "/" }),
 *   sources: ["/skills/user/", "/skills/project/"],
 * });
 * ```
 */
declare function createSkillsMiddleware(options: SkillsMiddlewareOptions): AgentMiddleware<StateSchema<{
  skillsMetadata: ReducedValue<{
    name: string;
    description: string;
    path: string;
    license?: string | null | undefined;
    compatibility?: string | null | undefined;
    metadata?: Record<string, string> | undefined;
    allowedTools?: string[] | undefined;
  }[] | undefined, {
    name: string;
    description: string;
    path: string;
    license?: string | null | undefined;
    compatibility?: string | null | undefined;
    metadata?: Record<string, string> | undefined;
    allowedTools?: string[] | undefined;
  }[] | undefined>;
  files: ReducedValue<FilesRecord | undefined, FilesRecordUpdate | undefined>;
}>, undefined, unknown, readonly (_langchain_core_tools0.ClientTool | _langchain_core_tools0.ServerTool)[]>;
//#endregion
//#region src/backends/store.d.ts
/**
 * Backend that stores files in LangGraph's BaseStore (persistent).
 *
 * Uses LangGraph's Store for persistent, cross-conversation storage.
 * Files are organized via namespaces and persist across all threads.
 *
 * The namespace can include an optional assistant_id for multi-agent isolation.
 */
declare class StoreBackend implements BackendProtocol {
  private stateAndStore;
  constructor(stateAndStore: StateAndStore);
  /**
   * Get the store instance.
   *
   * @returns BaseStore instance
   * @throws Error if no store is available
   */
  private getStore;
  /**
   * Get the namespace for store operations.
   *
   * If an assistant_id is available in stateAndStore, return
   * [assistant_id, "filesystem"] to provide per-assistant isolation.
   * Otherwise return ["filesystem"].
   */
  protected getNamespace(): string[];
  /**
   * Convert a store Item to FileData format.
   *
   * @param storeItem - The store Item containing file data
   * @returns FileData object
   * @throws Error if required fields are missing or have incorrect types
   */
  private convertStoreItemToFileData;
  /**
   * Convert FileData to a value suitable for store.put().
   *
   * @param fileData - The FileData to convert
   * @returns Object with content, created_at, and modified_at fields
   */
  private convertFileDataToStoreValue;
  /**
   * Search store with automatic pagination to retrieve all results.
   *
   * @param store - The store to search
   * @param namespace - Hierarchical path prefix to search within
   * @param options - Optional query, filter, and page_size
   * @returns List of all items matching the search criteria
   */
  private searchStorePaginated;
  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects for files and directories directly in the directory.
   *          Directories have a trailing / in their path and is_dir=true.
   */
  lsInfo(path: string): Promise<FileInfo[]>;
  /**
   * Read file content with line numbers.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset?: number, limit?: number): Promise<string>;
  /**
   * Read file content as raw FileData.
   *
   * @param filePath - Absolute file path
   * @returns Raw file content as FileData
   */
  readRaw(filePath: string): Promise<FileData>;
  /**
   * Create a new file with content.
   * Returns WriteResult. External storage sets filesUpdate=null.
   */
  write(filePath: string, content: string): Promise<WriteResult>;
  /**
   * Edit a file by replacing string occurrences.
   * Returns EditResult. External storage sets filesUpdate=null.
   */
  edit(filePath: string, oldString: string, newString: string, replaceAll?: boolean): Promise<EditResult>;
  /**
   * Structured search results or error string for invalid input.
   */
  grepRaw(pattern: string, path?: string, glob?: string | null): Promise<GrepMatch[] | string>;
  /**
   * Structured glob matching returning FileInfo objects.
   */
  globInfo(pattern: string, path?: string): Promise<FileInfo[]>;
  /**
   * Upload multiple files.
   *
   * @param files - List of [path, content] tuples to upload
   * @returns List of FileUploadResponse objects, one per input file
   */
  uploadFiles(files: Array<[string, Uint8Array]>): Promise<FileUploadResponse[]>;
  /**
   * Download multiple files.
   *
   * @param paths - List of file paths to download
   * @returns List of FileDownloadResponse objects, one per input path
   */
  downloadFiles(paths: string[]): Promise<FileDownloadResponse[]>;
}
//#endregion
//#region src/backends/filesystem.d.ts
/**
 * Backend that reads and writes files directly from the filesystem.
 *
 * Files are accessed using their actual filesystem paths. Relative paths are
 * resolved relative to the current working directory. Content is read/written
 * as plain text, and metadata (timestamps) are derived from filesystem stats.
 */
declare class FilesystemBackend implements BackendProtocol {
  private cwd;
  private virtualMode;
  private maxFileSizeBytes;
  constructor(options?: {
    rootDir?: string;
    virtualMode?: boolean;
    maxFileSizeMb?: number;
  });
  /**
   * Resolve a file path with security checks.
   *
   * When virtualMode=true, treat incoming paths as virtual absolute paths under
   * this.cwd, disallow traversal (.., ~) and ensure resolved path stays within root.
   * When virtualMode=false, preserve legacy behavior: absolute paths are allowed
   * as-is; relative paths resolve under cwd.
   *
   * @param key - File path (absolute, relative, or virtual when virtualMode=true)
   * @returns Resolved absolute path string
   * @throws Error if path traversal detected or path outside root
   */
  private resolvePath;
  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param dirPath - Absolute directory path to list files from
   * @returns List of FileInfo objects for files and directories directly in the directory.
   *          Directories have a trailing / in their path and is_dir=true.
   */
  lsInfo(dirPath: string): Promise<FileInfo[]>;
  /**
   * Read file content with line numbers.
   *
   * @param filePath - Absolute or relative file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset?: number, limit?: number): Promise<string>;
  /**
   * Read file content as raw FileData.
   *
   * @param filePath - Absolute file path
   * @returns Raw file content as FileData
   */
  readRaw(filePath: string): Promise<FileData>;
  /**
   * Create a new file with content.
   * Returns WriteResult. External storage sets filesUpdate=null.
   */
  write(filePath: string, content: string): Promise<WriteResult>;
  /**
   * Edit a file by replacing string occurrences.
   * Returns EditResult. External storage sets filesUpdate=null.
   */
  edit(filePath: string, oldString: string, newString: string, replaceAll?: boolean): Promise<EditResult>;
  /**
   * Search for a literal text pattern in files.
   *
   * Uses ripgrep if available, falling back to substring search.
   *
   * @param pattern - Literal string to search for (NOT regex).
   * @param dirPath - Directory or file path to search in. Defaults to current directory.
   * @param glob - Optional glob pattern to filter which files to search.
   * @returns List of GrepMatch dicts containing path, line number, and matched text.
   */
  grepRaw(pattern: string, dirPath?: string, glob?: string | null): Promise<GrepMatch[] | string>;
  /**
   * Search using ripgrep with fixed-string (literal) mode.
   *
   * @param pattern - Literal string to search for (unescaped).
   * @param baseFull - Resolved base path to search in.
   * @param includeGlob - Optional glob pattern to filter files.
   * @returns Dict mapping file paths to list of (line_number, line_text) tuples.
   *          Returns null if ripgrep is unavailable or times out.
   */
  private ripgrepSearch;
  /**
   * Fallback search using literal substring matching when ripgrep is unavailable.
   *
   * Recursively searches files, respecting maxFileSizeBytes limit.
   *
   * @param pattern - Literal string to search for.
   * @param baseFull - Resolved base path to search in.
   * @param includeGlob - Optional glob pattern to filter files by name.
   * @returns Dict mapping file paths to list of (line_number, line_text) tuples.
   */
  private literalSearch;
  /**
   * Structured glob matching returning FileInfo objects.
   */
  globInfo(pattern: string, searchPath?: string): Promise<FileInfo[]>;
  /**
   * Upload multiple files to the filesystem.
   *
   * @param files - List of [path, content] tuples to upload
   * @returns List of FileUploadResponse objects, one per input file
   */
  uploadFiles(files: Array<[string, Uint8Array]>): Promise<FileUploadResponse[]>;
  /**
   * Download multiple files from the filesystem.
   *
   * @param paths - List of file paths to download
   * @returns List of FileDownloadResponse objects, one per input path
   */
  downloadFiles(paths: string[]): Promise<FileDownloadResponse[]>;
}
//#endregion
//#region src/backends/composite.d.ts
/**
 * Backend that routes file operations to different backends based on path prefix.
 *
 * This enables hybrid storage strategies like:
 * - `/memories/` → StoreBackend (persistent, cross-thread)
 * - Everything else → StateBackend (ephemeral, per-thread)
 *
 * The CompositeBackend handles path prefix stripping/re-adding transparently.
 */
declare class CompositeBackend implements BackendProtocol {
  private default;
  private routes;
  private sortedRoutes;
  constructor(defaultBackend: BackendProtocol, routes: Record<string, BackendProtocol>);
  /**
   * Determine which backend handles this key and strip prefix.
   *
   * @param key - Original file path
   * @returns Tuple of [backend, stripped_key] where stripped_key has the route
   *          prefix removed (but keeps leading slash).
   */
  private getBackendAndKey;
  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects with route prefixes added, for files and directories
   *          directly in the directory. Directories have a trailing / in their path and is_dir=true.
   */
  lsInfo(path: string): Promise<FileInfo[]>;
  /**
   * Read file content, routing to appropriate backend.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset?: number, limit?: number): Promise<string>;
  /**
   * Read file content as raw FileData.
   *
   * @param filePath - Absolute file path
   * @returns Raw file content as FileData
   */
  readRaw(filePath: string): Promise<FileData>;
  /**
   * Structured search results or error string for invalid input.
   */
  grepRaw(pattern: string, path?: string, glob?: string | null): Promise<GrepMatch[] | string>;
  /**
   * Structured glob matching returning FileInfo objects.
   */
  globInfo(pattern: string, path?: string): Promise<FileInfo[]>;
  /**
   * Create a new file, routing to appropriate backend.
   *
   * @param filePath - Absolute file path
   * @param content - File content as string
   * @returns WriteResult with path or error
   */
  write(filePath: string, content: string): Promise<WriteResult>;
  /**
   * Edit a file, routing to appropriate backend.
   *
   * @param filePath - Absolute file path
   * @param oldString - String to find and replace
   * @param newString - Replacement string
   * @param replaceAll - If true, replace all occurrences
   * @returns EditResult with path, occurrences, or error
   */
  edit(filePath: string, oldString: string, newString: string, replaceAll?: boolean): Promise<EditResult>;
  /**
   * Execute a command via the default backend.
   * Execution is not path-specific, so it always delegates to the default backend.
   *
   * @param command - Full shell command string to execute
   * @returns ExecuteResponse with combined output, exit code, and truncation flag
   * @throws Error if the default backend doesn't support command execution
   */
  execute(command: string): Promise<ExecuteResponse>;
  /**
   * Upload multiple files, batching by backend for efficiency.
   *
   * @param files - List of [path, content] tuples to upload
   * @returns List of FileUploadResponse objects, one per input file
   */
  uploadFiles(files: Array<[string, Uint8Array]>): Promise<FileUploadResponse[]>;
  /**
   * Download multiple files, batching by backend for efficiency.
   *
   * @param paths - List of file paths to download
   * @returns List of FileDownloadResponse objects, one per input path
   */
  downloadFiles(paths: string[]): Promise<FileDownloadResponse[]>;
}
//#endregion
//#region src/backends/sandbox.d.ts
/**
 * Base sandbox implementation with execute() as the only abstract method.
 *
 * This class provides default implementations for all SandboxBackendProtocol
 * methods using shell commands executed via execute(). Concrete implementations
 * only need to implement execute(), uploadFiles(), and downloadFiles().
 *
 * All shell commands use pure POSIX utilities (awk, grep, find, stat) that are
 * available on any Linux including Alpine/busybox. No Python, Node.js, or
 * other runtime is required on the sandbox host.
 */
declare abstract class BaseSandbox implements SandboxBackendProtocol {
  /** Unique identifier for the sandbox backend */
  abstract readonly id: string;
  /**
   * Execute a command in the sandbox.
   * This is the only method concrete implementations must provide.
   */
  abstract execute(command: string): MaybePromise<ExecuteResponse>;
  /**
   * Upload multiple files to the sandbox.
   * Implementations must support partial success.
   */
  abstract uploadFiles(files: Array<[string, Uint8Array]>): MaybePromise<FileUploadResponse[]>;
  /**
   * Download multiple files from the sandbox.
   * Implementations must support partial success.
   */
  abstract downloadFiles(paths: string[]): MaybePromise<FileDownloadResponse[]>;
  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * Uses pure POSIX shell (find + stat) via execute() — works on any Linux
   * including Alpine. No Python or Node.js needed.
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects for files and directories directly in the directory.
   */
  lsInfo(path: string): Promise<FileInfo[]>;
  /**
   * Read file content with line numbers.
   *
   * Uses pure POSIX shell (awk) via execute() — only the requested slice
   * is returned over the wire, making this efficient for large files.
   * Works on any Linux including Alpine (no Python or Node.js needed).
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset?: number, limit?: number): Promise<string>;
  /**
   * Read file content as raw FileData.
   *
   * Uses downloadFiles() directly — no runtime needed on the sandbox host.
   *
   * @param filePath - Absolute file path
   * @returns Raw file content as FileData
   */
  readRaw(filePath: string): Promise<FileData>;
  /**
   * Search for a literal text pattern in files using grep.
   *
   * @param pattern - Literal string to search for (NOT regex).
   * @param path - Directory or file path to search in.
   * @param glob - Optional glob pattern to filter which files to search.
   * @returns List of GrepMatch dicts containing path, line number, and matched text.
   */
  grepRaw(pattern: string, path?: string, glob?: string | null): Promise<GrepMatch[] | string>;
  /**
   * Structured glob matching returning FileInfo objects.
   *
   * Uses pure POSIX shell (find + stat) via execute() to list all files,
   * then applies glob-to-regex matching in TypeScript. No Python or Node.js
   * needed on the sandbox host.
   *
   * Glob patterns are matched against paths relative to the search base:
   * - `*`  matches any characters except `/`
   * - `**` matches any characters including `/` (recursive)
   * - `?`  matches a single character except `/`
   * - `[...]` character classes
   */
  globInfo(pattern: string, path?: string): Promise<FileInfo[]>;
  /**
   * Create a new file with content.
   *
   * Uses downloadFiles() to check existence and uploadFiles() to write.
   * No runtime needed on the sandbox host.
   */
  write(filePath: string, content: string): Promise<WriteResult>;
  /**
   * Edit a file by replacing string occurrences.
   *
   * Uses downloadFiles() to read, performs string replacement in TypeScript,
   * then uploadFiles() to write back. No runtime needed on the sandbox host.
   */
  edit(filePath: string, oldString: string, newString: string, replaceAll?: boolean): Promise<EditResult>;
}
//#endregion
//#region src/types.d.ts
type AnyAnnotationRoot = AnnotationRoot<any>;
interface TypedToolStrategy<T = unknown> extends Array<ToolStrategy<any>> {
  _schemaType?: T;
}
/**
 * Helper type to extract middleware from a SubAgent definition
 * Handles both mutable and readonly middleware arrays
 */
type ExtractSubAgentMiddleware<T> = T extends {
  middleware?: infer M;
} ? M extends readonly AgentMiddleware[] ? M : M extends AgentMiddleware[] ? M : readonly [] : readonly [];
/**
 * Helper type to flatten and merge middleware from all subagents
 */
type FlattenSubAgentMiddleware<T extends readonly (SubAgent | CompiledSubAgent)[]> = T extends readonly [] ? readonly [] : T extends readonly [infer First, ...infer Rest] ? Rest extends readonly (SubAgent | CompiledSubAgent)[] ? readonly [...ExtractSubAgentMiddleware<First>, ...FlattenSubAgentMiddleware<Rest>] : ExtractSubAgentMiddleware<First> : readonly [];
/**
 * Helper type to merge states from subagent middleware
 */
type InferSubAgentMiddlewareStates<T extends readonly (SubAgent | CompiledSubAgent)[]> = InferMiddlewareStates<FlattenSubAgentMiddleware<T>>;
/**
 * Combined state type including custom middleware and subagent middleware states
 */
type MergedDeepAgentState<TMiddleware extends readonly AgentMiddleware[], TSubagents extends readonly (SubAgent | CompiledSubAgent)[]> = InferMiddlewareStates<TMiddleware> & InferSubAgentMiddlewareStates<TSubagents>;
/**
 * Union of all response format types accepted by `createDeepAgent`.
 *
 * Matches the formats supported by LangChain's `createAgent`:
 * - `ToolStrategy<T>` — from `ToolStrategy.fromSchema(schema)`
 * - `ProviderStrategy<T>` — from `providerStrategy(schema)`
 * - `TypedToolStrategy<T>` — from `toolStrategy(schema)`
 * - `ResponseFormat` — the base union of the above single-strategy types
 */
type SupportedResponseFormat = ResponseFormat | TypedToolStrategy<any>;
/**
 * Utility type to extract the parsed response type from a ResponseFormat strategy.
 *
 * Maps `ToolStrategy<T>`, `ProviderStrategy<T>`, and `TypedToolStrategy<T>` to `T`
 * (the parsed output type), so that `structuredResponse` is correctly typed as the
 * schema's inferred type rather than the strategy wrapper.
 *
 * When no `responseFormat` is provided (i.e. `T` defaults to the full
 * `SupportedResponseFormat` union), this resolves to `ResponseFormatUndefined` so
 * that `structuredResponse` is excluded from the agent's output state.
 *
 * @example
 * ```typescript
 * type T1 = InferStructuredResponse<ToolStrategy<{ city: string }>>; // { city: string }
 * type T2 = InferStructuredResponse<ProviderStrategy<{ answer: string }>>; // { answer: string }
 * type T3 = InferStructuredResponse<TypedToolStrategy<{ city: string }>>; // { city: string }
 * type T4 = InferStructuredResponse<SupportedResponseFormat>; // ResponseFormatUndefined (default/unset)
 * ```
 */
type InferStructuredResponse<T extends SupportedResponseFormat> = SupportedResponseFormat extends T ? ResponseFormatUndefined : T extends TypedToolStrategy<infer U> ? U : T extends ToolStrategy<infer U> ? U : T extends ProviderStrategy<infer U> ? U : ResponseFormatUndefined;
/**
 * Type bag that extends AgentTypeConfig with subagent type information.
 *
 * This interface bundles all the generic type parameters used throughout the deep agent system
 * including subagent types for type-safe streaming and delegation.
 *
 * @typeParam TResponse - The structured response type when using `responseFormat`.
 * @typeParam TState - The custom state schema type.
 * @typeParam TContext - The context schema type.
 * @typeParam TMiddleware - The middleware array type.
 * @typeParam TTools - The combined tools type.
 * @typeParam TSubagents - The subagents array type for type-safe streaming.
 *
 * @example
 * ```typescript
 * const agent = createDeepAgent({
 *   middleware: [ResearchMiddleware],
 *   subagents: [
 *     { name: "researcher", description: "...", middleware: [CounterMiddleware] }
 *   ] as const,
 * });
 *
 * // Type inference for streaming
 * type Types = InferDeepAgentType<typeof agent, "Subagents">;
 * ```
 */
interface DeepAgentTypeConfig<TResponse extends Record<string, any> | ResponseFormatUndefined = Record<string, any> | ResponseFormatUndefined, TState extends AnyAnnotationRoot | InteropZodObject | undefined = AnyAnnotationRoot | InteropZodObject | undefined, TContext extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot | InteropZodObject, TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[], TTools extends readonly (ClientTool | ServerTool)[] = readonly (ClientTool | ServerTool)[], TSubagents extends readonly (SubAgent | CompiledSubAgent)[] = readonly (SubAgent | CompiledSubAgent)[]> extends AgentTypeConfig<TResponse, TState, TContext, TMiddleware, TTools> {
  /** The subagents array type for type-safe streaming */
  Subagents: TSubagents;
}
/**
 * Default type configuration for deep agents.
 * Used when no explicit type parameters are provided.
 */
interface DefaultDeepAgentTypeConfig extends DeepAgentTypeConfig {
  Response: Record<string, any>;
  State: undefined;
  Context: AnyAnnotationRoot;
  Middleware: readonly AgentMiddleware[];
  Tools: readonly (ClientTool | ServerTool)[];
  Subagents: readonly (SubAgent | CompiledSubAgent)[];
}
/**
 * DeepAgent extends ReactAgent with additional subagent type information.
 *
 * This type wraps ReactAgent but includes the DeepAgentTypeConfig which
 * contains subagent types for type-safe streaming and delegation.
 *
 * @typeParam TTypes - The DeepAgentTypeConfig containing all type parameters
 *
 * @example
 * ```typescript
 * const agent: DeepAgent<DeepAgentTypeConfig<...>> = createDeepAgent({ ... });
 *
 * // Access subagent types for streaming
 * type Subagents = InferDeepAgentSubagents<typeof agent>;
 * ```
 */
type DeepAgent<TTypes extends DeepAgentTypeConfig = DeepAgentTypeConfig> = ReactAgent<TTypes> & {
  /** Type brand for DeepAgent type inference */readonly "~deepAgentTypes": TTypes;
};
/**
 * Helper type to resolve a DeepAgentTypeConfig from either:
 * - A DeepAgentTypeConfig directly
 * - A DeepAgent instance (using `typeof agent`)
 *
 * @example
 * ```typescript
 * const agent = createDeepAgent({ ... });
 * type Types = ResolveDeepAgentTypeConfig<typeof agent>;
 * ```
 */
type ResolveDeepAgentTypeConfig<T> = T extends {
  "~deepAgentTypes": infer Types;
} ? Types extends DeepAgentTypeConfig ? Types : never : T extends DeepAgentTypeConfig ? T : never;
/**
 * Helper type to extract any property from a DeepAgentTypeConfig or DeepAgent.
 *
 * @typeParam T - The DeepAgentTypeConfig or DeepAgent to extract from
 * @typeParam K - The property key to extract
 *
 * @example
 * ```typescript
 * const agent = createDeepAgent({ subagents: [...] });
 * type Subagents = InferDeepAgentType<typeof agent, "Subagents">;
 * ```
 */
type InferDeepAgentType<T, K extends keyof DeepAgentTypeConfig> = ResolveDeepAgentTypeConfig<T>[K];
/**
 * Shorthand helper to extract the Subagents type from a DeepAgentTypeConfig or DeepAgent.
 *
 * @example
 * ```typescript
 * const agent = createDeepAgent({ subagents: [subagent1, subagent2] });
 * type Subagents = InferDeepAgentSubagents<typeof agent>;
 * ```
 */
type InferDeepAgentSubagents<T> = InferDeepAgentType<T, "Subagents">;
/**
 * Helper type to extract a subagent by name from a DeepAgent.
 *
 * @typeParam T - The DeepAgent to extract from
 * @typeParam TName - The name of the subagent to extract
 *
 * @example
 * ```typescript
 * const agent = createDeepAgent({
 *   subagents: [
 *     { name: "researcher", description: "...", middleware: [ResearchMiddleware] }
 *   ] as const,
 * });
 *
 * type ResearcherAgent = InferSubagentByName<typeof agent, "researcher">;
 * ```
 */
type InferSubagentByName<T, TName extends string> = InferDeepAgentSubagents<T> extends readonly (infer SA)[] ? SA extends {
  name: TName;
} ? SA : never : never;
/**
 * Helper type to extract the ReactAgent type from a subagent definition.
 * This is useful for type-safe streaming of subagent events.
 *
 * @typeParam TSubagent - The subagent definition
 *
 * @example
 * ```typescript
 * type SubagentMiddleware = ExtractSubAgentMiddleware<typeof subagent>;
 * type SubagentState = InferMiddlewareStates<SubagentMiddleware>;
 * ```
 */
type InferSubagentReactAgentType<TSubagent extends SubAgent | CompiledSubAgent> = TSubagent extends CompiledSubAgent ? TSubagent["runnable"] : TSubagent extends SubAgent ? ReactAgent<AgentTypeConfig<ResponseFormatUndefined, undefined, AnyAnnotationRoot, ExtractSubAgentMiddleware<TSubagent>, readonly []>> : never;
/**
 * Configuration parameters for creating a Deep Agent
 * Matches Python's create_deep_agent parameters
 *
 * @typeParam TResponse - The structured response type when using responseFormat
 * @typeParam ContextSchema - The context schema type
 * @typeParam TMiddleware - The middleware array type for proper type inference
 * @typeParam TSubagents - The subagents array type for extracting subagent middleware states
 * @typeParam TTools - The tools array type
 */
interface CreateDeepAgentParams<TResponse extends SupportedResponseFormat = SupportedResponseFormat, ContextSchema extends AnnotationRoot<any> | InteropZodObject = AnnotationRoot<any>, TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[], TSubagents extends readonly (SubAgent | CompiledSubAgent)[] = readonly (SubAgent | CompiledSubAgent)[], TTools extends readonly (ClientTool | ServerTool)[] = readonly (ClientTool | ServerTool)[]> {
  /** The model to use (model name string or LanguageModelLike instance). Defaults to claude-sonnet-4-5-20250929 */
  model?: BaseLanguageModel | string;
  /** Tools the agent should have access to */
  tools?: TTools | StructuredTool$1[];
  /** Custom system prompt for the agent. This will be combined with the base agent prompt */
  systemPrompt?: string | SystemMessage;
  /** Custom middleware to apply after standard middleware */
  middleware?: TMiddleware;
  /** List of subagent specifications for task delegation */
  subagents?: TSubagents;
  /** Structured output response format for the agent (Zod schema or other format) */
  responseFormat?: TResponse;
  /** Optional schema for context (not persisted between invocations) */
  contextSchema?: ContextSchema;
  /** Optional checkpointer for persisting agent state between runs */
  checkpointer?: BaseCheckpointSaver | boolean;
  /** Optional store for persisting longterm memories */
  store?: BaseStore;
  /**
   * Optional backend for filesystem operations.
   * Can be either a backend instance or a factory function that creates one.
   * The factory receives a config object with state and store.
   */
  backend?: BackendProtocol | ((config: {
    state: unknown;
    store?: BaseStore;
  }) => BackendProtocol);
  /** Optional interrupt configuration mapping tool names to interrupt configs */
  interruptOn?: Record<string, boolean | InterruptOnConfig>;
  /** The name of the agent */
  name?: string;
  /**
   * Optional list of memory file paths (AGENTS.md files) to load
   * (e.g., ["~/.deepagents/AGENTS.md", "./.deepagents/AGENTS.md"]).
   * Display names are automatically derived from paths.
   * Memory is loaded at agent startup and added into the system prompt.
   */
  memory?: string[];
  /**
   * Optional list of skill source paths (e.g., `["/skills/user/", "/skills/project/"]`).
   *
   * Paths use POSIX conventions (forward slashes) and are relative to the backend's root.
   * Later sources override earlier ones for skills with the same name (last one wins).
   *
   * @example
   * ```typescript
   * // With FilesystemBackend - skills loaded from disk
   * const agent = await createDeepAgent({
   *   backend: new FilesystemBackend({ rootDir: "/home/user/.deepagents" }),
   *   skills: ["/skills/"],
   * });
   *
   * // With StateBackend - skills provided in state
   * const agent = await createDeepAgent({
   *   skills: ["/skills/"],
   * });
   * const result = await agent.invoke({
   *   messages: [...],
   *   files: {
   *     "/skills/my-skill/SKILL.md": {
   *       content: ["---", "name: my-skill", "description: ...", "---", "# My Skill"],
   *       created_at: new Date().toISOString(),
   *       modified_at: new Date().toISOString(),
   *     },
   *   },
   * });
   * ```
   */
  skills?: string[];
}
//#endregion
//#region src/agent.d.ts
/**
 * Create a Deep Agent with middleware-based architecture.
 *
 * Matches Python's create_deep_agent function, using middleware for all features:
 * - Todo management (todoListMiddleware)
 * - Filesystem tools (createFilesystemMiddleware)
 * - Subagent delegation (createSubAgentMiddleware)
 * - Conversation summarization (summarizationMiddleware)
 * - Prompt caching (anthropicPromptCachingMiddleware)
 * - Tool call patching (createPatchToolCallsMiddleware)
 * - Human-in-the-loop (humanInTheLoopMiddleware) - optional
 *
 * @param params Configuration parameters for the agent
 * @returns ReactAgent instance ready for invocation with properly inferred state types
 *
 * @example
 * ```typescript
 * // Middleware with custom state
 * const ResearchMiddleware = createMiddleware({
 *   name: "ResearchMiddleware",
 *   stateSchema: z.object({ research: z.string().default("") }),
 * });
 *
 * const agent = createDeepAgent({
 *   middleware: [ResearchMiddleware],
 * });
 *
 * const result = await agent.invoke({ messages: [...] });
 * // result.research is properly typed as string
 * ```
 */
declare function createDeepAgent<TResponse extends SupportedResponseFormat = SupportedResponseFormat, ContextSchema extends InteropZodObject = InteropZodObject, const TMiddleware extends readonly AgentMiddleware[] = readonly [], const TSubagents extends readonly (SubAgent | CompiledSubAgent)[] = readonly [], const TTools extends readonly (ClientTool | ServerTool)[] = readonly []>(params?: CreateDeepAgentParams<TResponse, ContextSchema, TMiddleware, TSubagents, TTools>): DeepAgent<DeepAgentTypeConfig<InferStructuredResponse<TResponse>, undefined, ContextSchema, readonly [AgentMiddleware<zod_v30.ZodObject<{
  todos: zod_v30.ZodDefault<zod_v30.ZodArray<zod_v30.ZodObject<{
    content: zod_v30.ZodString;
    status: zod_v30.ZodEnum<["pending", "in_progress", "completed"]>;
  }, "strip", zod_v30.ZodTypeAny, {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }, {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }>, "many">>;
}, "strip", zod_v30.ZodTypeAny, {
  todos: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[];
}, {
  todos?: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[] | undefined;
}>, undefined, unknown, readonly [langchain.DynamicStructuredTool<zod_v30.ZodObject<{
  todos: zod_v30.ZodArray<zod_v30.ZodObject<{
    content: zod_v30.ZodString;
    status: zod_v30.ZodEnum<["pending", "in_progress", "completed"]>;
  }, "strip", zod_v30.ZodTypeAny, {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }, {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }>, "many">;
}, "strip", zod_v30.ZodTypeAny, {
  todos: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[];
}, {
  todos: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[];
}>, {
  todos: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[];
}, {
  todos: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[];
}, _langchain_langgraph0.Command<unknown, {
  todos: {
    content: string;
    status: "completed" | "in_progress" | "pending";
  }[];
  messages: _messages.ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>>[];
}, string>, "write_todos">]>, AgentMiddleware<_langchain_langgraph0.StateSchema<{
  files: _langchain_langgraph0.ReducedValue<FilesRecord | undefined, FilesRecordUpdate | undefined>;
}>, undefined, unknown, (langchain.DynamicStructuredTool<zod.ZodObject<{
  path: zod.ZodDefault<zod.ZodOptional<zod.ZodString>>;
}, zod_v4_core0.$strip>, {
  path: string;
}, {
  path?: string | undefined;
}, string, "ls"> | langchain.DynamicStructuredTool<zod.ZodObject<{
  file_path: zod.ZodString;
  offset: zod.ZodDefault<zod.ZodOptional<zod.ZodCoercedNumber<unknown>>>;
  limit: zod.ZodDefault<zod.ZodOptional<zod.ZodCoercedNumber<unknown>>>;
}, zod_v4_core0.$strip>, {
  file_path: string;
  offset: number;
  limit: number;
}, {
  file_path: string;
  offset?: unknown;
  limit?: unknown;
}, string, "read_file"> | langchain.DynamicStructuredTool<zod.ZodObject<{
  file_path: zod.ZodString;
  content: zod.ZodString;
}, zod_v4_core0.$strip>, {
  file_path: string;
  content: string;
}, {
  file_path: string;
  content: string;
}, string | _messages.ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>> | _langchain_langgraph0.Command<unknown, {
  files: Record<string, FileData>;
  messages: _messages.ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>>[];
}, string>, "write_file"> | langchain.DynamicStructuredTool<zod.ZodObject<{
  file_path: zod.ZodString;
  old_string: zod.ZodString;
  new_string: zod.ZodString;
  replace_all: zod.ZodDefault<zod.ZodOptional<zod.ZodBoolean>>;
}, zod_v4_core0.$strip>, {
  file_path: string;
  old_string: string;
  new_string: string;
  replace_all: boolean;
}, {
  file_path: string;
  old_string: string;
  new_string: string;
  replace_all?: boolean | undefined;
}, string | _messages.ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>> | _langchain_langgraph0.Command<unknown, {
  files: Record<string, FileData>;
  messages: _messages.ToolMessage<_messages.MessageStructure<_messages.MessageToolSet>>[];
}, string>, "edit_file"> | langchain.DynamicStructuredTool<zod.ZodObject<{
  pattern: zod.ZodString;
  path: zod.ZodDefault<zod.ZodOptional<zod.ZodString>>;
}, zod_v4_core0.$strip>, {
  pattern: string;
  path: string;
}, {
  pattern: string;
  path?: string | undefined;
}, string, "glob"> | langchain.DynamicStructuredTool<zod.ZodObject<{
  pattern: zod.ZodString;
  path: zod.ZodDefault<zod.ZodOptional<zod.ZodString>>;
  glob: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;
}, zod_v4_core0.$strip>, {
  pattern: string;
  path: string;
  glob?: string | null | undefined;
}, {
  pattern: string;
  path?: string | undefined;
  glob?: string | null | undefined;
}, string, "grep"> | langchain.DynamicStructuredTool<zod.ZodObject<{
  command: zod.ZodString;
}, zod_v4_core0.$strip>, {
  command: string;
}, {
  command: string;
}, string, "execute">)[]>, AgentMiddleware<undefined, undefined, unknown, readonly [langchain.DynamicStructuredTool<zod.ZodObject<{
  description: zod.ZodString;
  subagent_type: zod.ZodString;
}, zod_v4_core0.$strip>, {
  description: string;
  subagent_type: string;
}, {
  description: string;
  subagent_type: string;
}, string | _langchain_langgraph0.Command<unknown, Record<string, unknown>, string>, "task">]>, AgentMiddleware<undefined, zod_v30.ZodObject<{
  trigger: zod_v30.ZodOptional<zod_v30.ZodUnion<[zod_v30.ZodEffects<zod_v30.ZodObject<{
    fraction: zod_v30.ZodOptional<zod_v30.ZodNumber>;
    tokens: zod_v30.ZodOptional<zod_v30.ZodNumber>;
    messages: zod_v30.ZodOptional<zod_v30.ZodNumber>;
  }, "strip", zod_v30.ZodTypeAny, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }>, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }>, zod_v30.ZodArray<zod_v30.ZodEffects<zod_v30.ZodObject<{
    fraction: zod_v30.ZodOptional<zod_v30.ZodNumber>;
    tokens: zod_v30.ZodOptional<zod_v30.ZodNumber>;
    messages: zod_v30.ZodOptional<zod_v30.ZodNumber>;
  }, "strip", zod_v30.ZodTypeAny, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }>, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }>, "many">]>>;
  keep: zod_v30.ZodOptional<zod_v30.ZodEffects<zod_v30.ZodObject<{
    fraction: zod_v30.ZodOptional<zod_v30.ZodNumber>;
    tokens: zod_v30.ZodOptional<zod_v30.ZodNumber>;
    messages: zod_v30.ZodOptional<zod_v30.ZodNumber>;
  }, "strip", zod_v30.ZodTypeAny, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }>, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }, {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }>>;
  tokenCounter: zod_v30.ZodOptional<zod_v30.ZodFunction<zod_v30.ZodTuple<[zod_v30.ZodArray<zod_v30.ZodType<_messages.BaseMessage<_messages.MessageStructure<_messages.MessageToolSet>, _messages.MessageType>, zod_v30.ZodTypeDef, _messages.BaseMessage<_messages.MessageStructure<_messages.MessageToolSet>, _messages.MessageType>>, "many">], zod_v30.ZodUnknown>, zod_v30.ZodUnion<[zod_v30.ZodNumber, zod_v30.ZodPromise<zod_v30.ZodNumber>]>>>;
  summaryPrompt: zod_v30.ZodDefault<zod_v30.ZodString>;
  trimTokensToSummarize: zod_v30.ZodOptional<zod_v30.ZodNumber>;
  summaryPrefix: zod_v30.ZodOptional<zod_v30.ZodString>;
  maxTokensBeforeSummary: zod_v30.ZodOptional<zod_v30.ZodNumber>;
  messagesToKeep: zod_v30.ZodOptional<zod_v30.ZodNumber>;
} & {
  model: zod_v30.ZodOptional<zod_v30.ZodType<_langchain_core_language_models_base0.BaseLanguageModel<any, _langchain_core_language_models_base0.BaseLanguageModelCallOptions>, zod_v30.ZodTypeDef, _langchain_core_language_models_base0.BaseLanguageModel<any, _langchain_core_language_models_base0.BaseLanguageModelCallOptions>>>;
}, "strip", zod_v30.ZodTypeAny, {
  trigger?: {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }[] | {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  } | undefined;
  keep?: {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  } | undefined;
  tokenCounter?: ((args_0: _messages.BaseMessage<_messages.MessageStructure<_messages.MessageToolSet>, _messages.MessageType>[], ...args: unknown[]) => number | Promise<number>) | undefined;
  summaryPrompt: string;
  trimTokensToSummarize?: number | undefined;
  summaryPrefix?: string | undefined;
  maxTokensBeforeSummary?: number | undefined;
  messagesToKeep?: number | undefined;
  model?: _langchain_core_language_models_base0.BaseLanguageModel<any, _langchain_core_language_models_base0.BaseLanguageModelCallOptions> | undefined;
}, {
  trigger?: {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }[] | {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  } | undefined;
  keep?: {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  } | undefined;
  tokenCounter?: ((args_0: _messages.BaseMessage<_messages.MessageStructure<_messages.MessageToolSet>, _messages.MessageType>[], ...args: unknown[]) => number | Promise<number>) | undefined;
  summaryPrompt?: string | undefined;
  trimTokensToSummarize?: number | undefined;
  summaryPrefix?: string | undefined;
  maxTokensBeforeSummary?: number | undefined;
  messagesToKeep?: number | undefined;
  model?: _langchain_core_language_models_base0.BaseLanguageModel<any, _langchain_core_language_models_base0.BaseLanguageModelCallOptions> | undefined;
}>, {
  trigger?: {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  }[] | {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  } | undefined;
  keep?: {
    fraction?: number | undefined;
    tokens?: number | undefined;
    messages?: number | undefined;
  } | undefined;
  tokenCounter?: ((args_0: _messages.BaseMessage<_messages.MessageStructure<_messages.MessageToolSet>, _messages.MessageType>[], ...args: unknown[]) => number | Promise<number>) | undefined;
  summaryPrompt: string;
  trimTokensToSummarize?: number | undefined;
  summaryPrefix?: string | undefined;
  maxTokensBeforeSummary?: number | undefined;
  messagesToKeep?: number | undefined;
  model?: _langchain_core_language_models_base0.BaseLanguageModel<any, _langchain_core_language_models_base0.BaseLanguageModelCallOptions> | undefined;
}, readonly (ClientTool | ServerTool)[]>, AgentMiddleware<undefined, zod_v30.ZodObject<{
  enableCaching: zod_v30.ZodOptional<zod_v30.ZodBoolean>;
  ttl: zod_v30.ZodOptional<zod_v30.ZodEnum<["5m", "1h"]>>;
  minMessagesToCache: zod_v30.ZodOptional<zod_v30.ZodNumber>;
  unsupportedModelBehavior: zod_v30.ZodOptional<zod_v30.ZodEnum<["ignore", "warn", "raise"]>>;
}, "strip", zod_v30.ZodTypeAny, {
  enableCaching?: boolean | undefined;
  ttl?: "1h" | "5m" | undefined;
  minMessagesToCache?: number | undefined;
  unsupportedModelBehavior?: "ignore" | "raise" | "warn" | undefined;
}, {
  enableCaching?: boolean | undefined;
  ttl?: "1h" | "5m" | undefined;
  minMessagesToCache?: number | undefined;
  unsupportedModelBehavior?: "ignore" | "raise" | "warn" | undefined;
}>, {
  enableCaching?: boolean | undefined;
  ttl?: "1h" | "5m" | undefined;
  minMessagesToCache?: number | undefined;
  unsupportedModelBehavior?: "ignore" | "raise" | "warn" | undefined;
}, readonly (ClientTool | ServerTool)[]>, AgentMiddleware<undefined, undefined, unknown, readonly (ClientTool | ServerTool)[]>, ...TMiddleware, ...FlattenSubAgentMiddleware<TSubagents>], TTools, TSubagents>>;
//#endregion
//#region src/config.d.ts
/**
 * Configuration and settings for deepagents.
 *
 * Provides project detection, path management, and environment configuration
 * for skills and agent memory middleware.
 */
/**
 * Options for creating a Settings instance.
 */
interface SettingsOptions {
  /** Starting directory for project detection (defaults to cwd) */
  startPath?: string;
}
/**
 * Settings interface for project detection and path management.
 *
 * Provides access to:
 * - Project root detection (via .git directory)
 * - User-level deepagents directory (~/.deepagents)
 * - Agent-specific directories and files
 * - Skills directories (user and project level)
 */
interface Settings {
  /** Detected project root directory, or null if not in a git project */
  readonly projectRoot: string | null;
  /** Base user-level .deepagents directory (~/.deepagents) */
  readonly userDeepagentsDir: string;
  /** Check if currently in a git project */
  readonly hasProject: boolean;
  /**
   * Get the agent directory path.
   * @param agentName - Name of the agent
   * @returns Path to ~/.deepagents/{agentName}
   * @throws Error if agent name is invalid
   */
  getAgentDir(agentName: string): string;
  /**
   * Ensure agent directory exists and return path.
   * @param agentName - Name of the agent
   * @returns Path to ~/.deepagents/{agentName}
   * @throws Error if agent name is invalid
   */
  ensureAgentDir(agentName: string): string;
  /**
   * Get user-level agent.md path for a specific agent.
   * @param agentName - Name of the agent
   * @returns Path to ~/.deepagents/{agentName}/agent.md
   */
  getUserAgentMdPath(agentName: string): string;
  /**
   * Get project-level agent.md path.
   * @returns Path to {projectRoot}/.deepagents/agent.md, or null if not in a project
   */
  getProjectAgentMdPath(): string | null;
  /**
   * Get user-level skills directory path for a specific agent.
   * @param agentName - Name of the agent
   * @returns Path to ~/.deepagents/{agentName}/skills/
   */
  getUserSkillsDir(agentName: string): string;
  /**
   * Ensure user-level skills directory exists and return path.
   * @param agentName - Name of the agent
   * @returns Path to ~/.deepagents/{agentName}/skills/
   */
  ensureUserSkillsDir(agentName: string): string;
  /**
   * Get project-level skills directory path.
   * @returns Path to {projectRoot}/.deepagents/skills/, or null if not in a project
   */
  getProjectSkillsDir(): string | null;
  /**
   * Ensure project-level skills directory exists and return path.
   * @returns Path to {projectRoot}/.deepagents/skills/, or null if not in a project
   */
  ensureProjectSkillsDir(): string | null;
  /**
   * Ensure project .deepagents directory exists.
   * @returns Path to {projectRoot}/.deepagents/, or null if not in a project
   */
  ensureProjectDeepagentsDir(): string | null;
}
/**
 * Find the project root by looking for .git directory.
 *
 * Walks up the directory tree from startPath (or cwd) looking for a .git
 * directory, which indicates the project root.
 *
 * @param startPath - Directory to start searching from. Defaults to current working directory.
 * @returns Path to the project root if found, null otherwise.
 */
declare function findProjectRoot(startPath?: string): string | null;
/**
 * Create a Settings instance with detected environment.
 *
 * @param options - Configuration options
 * @returns Settings instance with project detection and path management
 */
declare function createSettings(options?: SettingsOptions): Settings;
//#endregion
//#region src/values.d.ts
/**
 * Shared ReducedValue for file data state management.
 *
 * This provides a reusable pattern for managing file state with automatic
 * merging of concurrent updates from parallel subagents. Files can be updated
 * or deleted (using null values) and the reducer handles the merge logic.
 *
 * Similar to LangGraph's messagesValue, this encapsulates the common pattern
 * of managing files in agent state so you don't have to manually configure
 * the ReducedValue each time.
 *
 * @example
 * ```typescript
 * import { filesValue } from "@anthropic/deepagents";
 * import { StateSchema } from "@langchain/langgraph";
 *
 * const MyStateSchema = new StateSchema({
 *   files: filesValue,
 *   // ... other state fields
 * });
 * ```
 */
declare const filesValue: ReducedValue<FilesRecord | undefined, FilesRecordUpdate | undefined>;
//#endregion
//#region src/middleware/agent-memory.d.ts
/**
 * Options for the agent memory middleware.
 */
interface AgentMemoryMiddlewareOptions {
  /** Settings instance with project detection and paths */
  settings: Settings;
  /** The agent identifier */
  assistantId: string;
  /** Optional custom template for injecting agent memory into system prompt */
  systemPromptTemplate?: string;
}
/**
 * Create middleware for loading agent-specific long-term memory.
 *
 * This middleware loads the agent's long-term memory from a file (agent.md)
 * and injects it into the system prompt. The memory is loaded once at the
 * start of the conversation and stored in state.
 *
 * @param options - Configuration options
 * @returns AgentMiddleware for memory loading and injection
 *
 * @deprecated Use `createMemoryMiddleware` from `./memory.js` instead.
 * This function uses direct filesystem access which limits portability.
 */
declare function createAgentMemoryMiddleware(options: AgentMemoryMiddlewareOptions): AgentMiddleware<any, undefined, unknown, readonly (_langchain_core_tools0.ClientTool | _langchain_core_tools0.ServerTool)[]>;
//#endregion
//#region src/skills/loader.d.ts
/**
 * Metadata for a skill per Agent Skills spec.
 * @see https://agentskills.io/specification
 */
interface SkillMetadata {
  /** Name of the skill (max 64 chars, lowercase alphanumeric and hyphens) */
  name: string;
  /** Description of what the skill does (max 1024 chars) */
  description: string;
  /** Absolute path to the SKILL.md file */
  path: string;
  /** Source of the skill ('user' or 'project') */
  source: "user" | "project";
  /** Optional: License name or reference to bundled license file */
  license?: string;
  /** Optional: Environment requirements (max 500 chars) */
  compatibility?: string;
  /** Optional: Arbitrary key-value mapping for additional metadata */
  metadata?: Record<string, string>;
  /** Optional: Space-delimited list of pre-approved tools */
  allowedTools?: string;
}
/**
 * Options for listing skills.
 */
interface ListSkillsOptions {
  /** Path to user-level skills directory */
  userSkillsDir?: string | null;
  /** Path to project-level skills directory */
  projectSkillsDir?: string | null;
}
/**
 * Parse YAML frontmatter from a SKILL.md file per Agent Skills spec.
 *
 * @param skillMdPath - Path to the SKILL.md file
 * @param source - Source of the skill ('user' or 'project')
 * @returns SkillMetadata with all fields, or null if parsing fails
 */
declare function parseSkillMetadata(skillMdPath: string, source: "user" | "project"): SkillMetadata | null;
/**
 * List skills from user and/or project directories.
 *
 * When both directories are provided, project skills with the same name as
 * user skills will override them.
 *
 * @param options - Options specifying which directories to search
 * @returns Merged list of skill metadata from both sources, with project skills
 *          taking precedence over user skills when names conflict
 */
declare function listSkills(options: ListSkillsOptions): SkillMetadata[];
//#endregion
export { type AgentMemoryMiddlewareOptions, type BackendFactory, type BackendProtocol, BaseSandbox, type CompiledSubAgent, CompositeBackend, type CreateDeepAgentParams, DEFAULT_GENERAL_PURPOSE_DESCRIPTION, DEFAULT_SUBAGENT_PROMPT, type DeepAgent, type DeepAgentTypeConfig, type DefaultDeepAgentTypeConfig, type EditResult, type ExecuteResponse, type ExtractSubAgentMiddleware, type FileData, type FileDownloadResponse, type FileInfo, type FileOperationError, type FileUploadResponse, FilesystemBackend, type FilesystemMiddlewareOptions, type FlattenSubAgentMiddleware, GENERAL_PURPOSE_SUBAGENT, type GrepMatch, type InferDeepAgentSubagents, type InferDeepAgentType, type InferStructuredResponse, type InferSubAgentMiddlewareStates, type InferSubagentByName, type InferSubagentReactAgentType, type ListSkillsOptions, type SkillMetadata as LoaderSkillMetadata, MAX_SKILL_DESCRIPTION_LENGTH, MAX_SKILL_FILE_SIZE, MAX_SKILL_NAME_LENGTH, type MaybePromise, type MemoryMiddlewareOptions, type MergedDeepAgentState, type ResolveDeepAgentTypeConfig, type SandboxBackendProtocol, type SandboxDeleteOptions, SandboxError, type SandboxErrorCode, type SandboxGetOrCreateOptions, type SandboxInfo, type SandboxListOptions, type SandboxListResponse, type Settings, type SettingsOptions, type SkillMetadata$1 as SkillMetadata, type SkillsMiddlewareOptions, StateBackend, StoreBackend, type SubAgent, type SubAgentMiddlewareOptions, type SupportedResponseFormat, TASK_SYSTEM_PROMPT, type WriteResult, createAgentMemoryMiddleware, createDeepAgent, createFilesystemMiddleware, createMemoryMiddleware, createPatchToolCallsMiddleware, createSettings, createSkillsMiddleware, createSubAgentMiddleware, filesValue, findProjectRoot, isSandboxBackend, listSkills, parseSkillMetadata };
//# sourceMappingURL=index.d.cts.map